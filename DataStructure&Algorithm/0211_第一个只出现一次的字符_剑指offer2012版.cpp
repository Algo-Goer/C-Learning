// 题目：在字符串中找出第一个只出现一次的字符。如输入"abaccdeff"，则输出'b'
/**
 * 思路：
 * 看到这道题时，最直观想法是：从头开始扫描这个字符串中的每个字符。当访问到某字符时拿这个字符和后面字符相比较，
 * 如果在后面没有发现重复的字符，则该字符就是只出现一次的字符。
 * 如果字符串有n个字符，每个字符可能与后面的O(n)个字符相比较，因此这种思路的时间复杂度是O(n^2)
 * 但面试官不会满意这种思路，他会提示我们还有更快的方法
 * 
 * 由于题目与字符出现的次数相关，我们是不是可以统计每个字符在该字符串中出现的次数？
 * 要达到这个目的，我们需要一个数据容器来存放每个字符的出现次数。
 * 这个数据容器中，可以根据字符来查找它出现的次数，也就是说这个容器的作用是把一个字符映射成一个数字。
 * 在常用的数据容器中，哈希表正是这个用途。
 * 
 * 为了解决这个问题，我们可以定义哈希表的键值(Key)是字符，而值(Value)是该字符出现的次数。
 * 同时我们还需要从头开始扫描字符串两次。
 * 第一次扫描字符串时，每扫描到一个字符就在哈希表的对应项中把次数加1。
 * 接下来第二次扫描时，每扫描到一个字符就能从哈希表中得到该字符出现的次数。
 * 这样第一个只出现一次的字符就是符合要求的输出。
 * 
 * 哈希表是一种比较复杂的数据结构，且C++的标准模板库中没有实现哈希表。
 * 接下来我们要考虑的问题就是如何实现哈希表。
 * 由于本题的特殊性，我们只需要一个非常简单的哈希表就能满足要求。
 * 字符(char)是一个长度为8的数据类型，因此总共有256种可能。
 * 于是我们创建一个长度为256的数组，每个字母根据其ASCII码值作为数据的下标对应数组的一个数字，
 * 而数组中存储的是每个字符出现的次数。
 * 这样我们就创建了一个大小为256，以字符ASCII码为键值的哈希表。
 * 
 * 第一次扫描时，在哈希表中更新一个字符出现的次数的时间是O(1)。
 * 如果字符串长度为n，那么第一次扫描的时间复杂度是O(n)。
 * 第二次扫描时，同样O(1)能读出一个字符出现的次数，所以时间复杂度仍然是O(n)。
 * 这样总的时间复杂度是O(n)。
 * 同时，我们需要一个包含256个字符的辅助数组，它的大小是1K。
 * 由于这个数组大小是个常数，因此可以认为这种算法的空间复杂度是O(1)。
 * 
 * 当我们向面试官讲清楚上述思路，并得到面试官首肯之后，就可以手撕代码了。
 * 下面是一段C++参考代码
 */

char FirstNotRepeatingChar(char* pString)
{
    if (pString == NULL)
        return '\0';
    const int tableSize = 256;
    unsigned int hashTable[tableSize];
    for (unsigned int i = 0; i < tableSize; ++i)
        hashTable[i] = 0;

    char* pHashKey = pString;
    while (* (pHashKey) != '\0')
        hashTable[* (pHashKey++)]++;

    pHashKey = pString;
    while (*pHashKey != '\0')
    {
        if (hashTable[*pHashKey] == 1)
            return *pHashKey;
        pHashKey++;
    }
    
    return '\0';
}